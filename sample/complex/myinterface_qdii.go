// Code generated by "qdiimpl"; DO NOT EDIT.
package main

import (
	"context"
	"fmt"
	"runtime"
	"sync"
)

type QDMyInterfaceContext struct {
	MethodName     string
	ExecCount      int
	CallerFunc     string
	CallerFile     string
	CallerLine     int
	isNotSupported bool
	Data           any
}

// NotSupported should be called if the current callback don't support the passed arguments.
// The function return values will be ignored.
func (c *QDMyInterfaceContext) NotSupported() {
	c.isNotSupported = true
}

type qdMyInterface[T any, X II] struct {
	DataQDII any

	lock                   sync.Mutex
	execCount              map[string]int
	fallback               MyInterface[T, X]
	onMethodNotImplemented func(qdCtx *QDMyInterfaceContext, hasCallbacks bool) error
	implCloseNotify        []func(qdCtx *QDMyInterfaceContext) <-chan bool
	implData               []func(qdCtx *QDMyInterfaceContext)
	implGet                []func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string) (x1 T, err error)
	implOther              []func(qdCtx *QDMyInterfaceContext, si SecondInterface) int
	implOther2             []func(qdCtx *QDMyInterfaceContext, ti ThirdInterface[T]) int
	implSet                []func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string, value T) error
	implUnnamed            []func(qdCtx *QDMyInterfaceContext, p0 bool, p1 string)
	implXGet               []func(qdCtx *QDMyInterfaceContext, ss *SI) *SI
	implXGet2              []func(qdCtx *QDMyInterfaceContext, ss *XI) *XI
	implinternal           []func(qdCtx *QDMyInterfaceContext) bool
}

type QDMyInterfaceOption[T any, X II] func(*qdMyInterface[T, X])

func NewQDMyInterface[T any, X II](options ...QDMyInterfaceOption[T, X]) MyInterface[T, X] {
	ret := &qdMyInterface[T, X]{execCount: map[string]int{}}
	for _, opt := range options {
		opt(ret)
	}
	return ret
}

// CloseNotify implements [main.MyInterface.CloseNotify].
func (d *qdMyInterface[T, X]) CloseNotify() <-chan bool {
	const methodName = "CloseNotify"
	for _, impl := range d.implCloseNotify {
		qctx := d.createContext(methodName)
		r0 := impl(qctx)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.CloseNotify()
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implCloseNotify) > 0))
}

// Data implements [main.MyInterface.Data].
func (d *qdMyInterface[T, X]) Data() {
	const methodName = "Data"
	for _, impl := range d.implData {
		qctx := d.createContext(methodName)
		impl(qctx)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return
		}
	}
	if d.fallback != nil {
		d.fallback.Data()
		return
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implData) > 0))
}

// Get implements [main.MyInterface.Get].
func (d *qdMyInterface[T, X]) Get(ctx context.Context, name string) (x1 T, err error) {
	const methodName = "Get"
	for _, impl := range d.implGet {
		qctx := d.createContext(methodName)
		r0, r1 := impl(qctx, ctx, name)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0, r1
		}
	}
	if d.fallback != nil {
		return d.fallback.Get(ctx, name)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implGet) > 0))
}

// Other implements [main.MyInterface.Other].
func (d *qdMyInterface[T, X]) Other(si SecondInterface) int {
	const methodName = "Other"
	for _, impl := range d.implOther {
		qctx := d.createContext(methodName)
		r0 := impl(qctx, si)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.Other(si)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implOther) > 0))
}

// Other2 implements [main.MyInterface.Other2].
func (d *qdMyInterface[T, X]) Other2(ti ThirdInterface[T]) int {
	const methodName = "Other2"
	for _, impl := range d.implOther2 {
		qctx := d.createContext(methodName)
		r0 := impl(qctx, ti)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.Other2(ti)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implOther2) > 0))
}

// Set implements [main.MyInterface.Set].
func (d *qdMyInterface[T, X]) Set(ctx context.Context, name string, value T) error {
	const methodName = "Set"
	for _, impl := range d.implSet {
		qctx := d.createContext(methodName)
		r0 := impl(qctx, ctx, name, value)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.Set(ctx, name, value)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implSet) > 0))
}

// Unnamed implements [main.MyInterface.Unnamed].
func (d *qdMyInterface[T, X]) Unnamed(p0 bool, p1 string) {
	const methodName = "Unnamed"
	for _, impl := range d.implUnnamed {
		qctx := d.createContext(methodName)
		impl(qctx, p0, p1)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return
		}
	}
	if d.fallback != nil {
		d.fallback.Unnamed(p0, p1)
		return
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implUnnamed) > 0))
}

// XGet implements [main.MyInterface.XGet].
func (d *qdMyInterface[T, X]) XGet(ss *SI) *SI {
	const methodName = "XGet"
	for _, impl := range d.implXGet {
		qctx := d.createContext(methodName)
		r0 := impl(qctx, ss)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.XGet(ss)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implXGet) > 0))
}

// XGet2 implements [main.MyInterface.XGet2].
func (d *qdMyInterface[T, X]) XGet2(ss *XI) *XI {
	const methodName = "XGet2"
	for _, impl := range d.implXGet2 {
		qctx := d.createContext(methodName)
		r0 := impl(qctx, ss)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.XGet2(ss)
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implXGet2) > 0))
}

// internal implements [main.MyInterface.internal].
func (d *qdMyInterface[T, X]) internal() bool {
	const methodName = "internal"
	for _, impl := range d.implinternal {
		qctx := d.createContext(methodName)
		r0 := impl(qctx)
		if !qctx.isNotSupported {
			d.addCallMethod(methodName)
			return r0
		}
	}
	if d.fallback != nil {
		return d.fallback.internal()
	}
	panic(d.methodNotImplemented(d.createContext(methodName), len(d.implinternal) > 0))
}

func (d *qdMyInterface[T, X]) getCallerFuncName(skip int) (funcName string, file string, line int) {
	counter, file, line, success := runtime.Caller(skip)
	if !success {
		panic("runtime.Caller failed")
	}
	return runtime.FuncForPC(counter).Name(), file, line
}

func (d *qdMyInterface[T, X]) addCallMethod(methodName string) {
	d.lock.Lock()
	defer d.lock.Unlock()
	d.execCount[methodName]++
}

func (d *qdMyInterface[T, X]) createContext(methodName string) *QDMyInterfaceContext {
	callerFunc, callerFile, callerLine := d.getCallerFuncName(3)
	d.lock.Lock()
	defer d.lock.Unlock()
	return &QDMyInterfaceContext{
		MethodName: methodName,
		ExecCount:  d.execCount[methodName],
		CallerFunc: callerFunc,
		CallerFile: callerFile,
		CallerLine: callerLine,
		Data:       d.DataQDII,
	}
}

func (d *qdMyInterface[T, X]) methodNotImplemented(qdCtx *QDMyInterfaceContext, hasCallbacks bool) error {
	if d.onMethodNotImplemented != nil {
		return d.onMethodNotImplemented(qdCtx, hasCallbacks)
	}
	msg := "not implemented"
	if !hasCallbacks {
		msg = "not supported by any callbacks"
	}
	msg = "not supported by any callbacks"
	return fmt.Errorf("[qdMyInterface] method '%s' %s", qdCtx.MethodName, msg)
}

// Options

func WithDataQDII[T any, X II](data any) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.DataQDII = data
	}
}

func WithFallback[T any, X II](fallback MyInterface[T, X]) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.fallback = fallback
	}
}

func WithOnMethodNotImplemented[T any, X II](m func(qdCtx *QDMyInterfaceContext, hasCallbacks bool) error) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.onMethodNotImplemented = m
	}
}

// WithCloseNotify implements [main.MyInterface.CloseNotify].
func WithCloseNotify[T any, X II](implCloseNotify func(qdCtx *QDMyInterfaceContext) <-chan bool) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implCloseNotify = append(d.implCloseNotify, implCloseNotify)
	}
}

// WithData implements [main.MyInterface.Data].
func WithData[T any, X II](implData func(qdCtx *QDMyInterfaceContext)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implData = append(d.implData, implData)
	}
}

// WithGet implements [main.MyInterface.Get].
func WithGet[T any, X II](implGet func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string) (x1 T, err error)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implGet = append(d.implGet, implGet)
	}
}

// WithOther implements [main.MyInterface.Other].
func WithOther[T any, X II](implOther func(qdCtx *QDMyInterfaceContext, si SecondInterface) int) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implOther = append(d.implOther, implOther)
	}
}

// WithOther2 implements [main.MyInterface.Other2].
func WithOther2[T any, X II](implOther2 func(qdCtx *QDMyInterfaceContext, ti ThirdInterface[T]) int) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implOther2 = append(d.implOther2, implOther2)
	}
}

// WithSet implements [main.MyInterface.Set].
func WithSet[T any, X II](implSet func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string, value T) error) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implSet = append(d.implSet, implSet)
	}
}

// WithUnnamed implements [main.MyInterface.Unnamed].
func WithUnnamed[T any, X II](implUnnamed func(qdCtx *QDMyInterfaceContext, p0 bool, p1 string)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implUnnamed = append(d.implUnnamed, implUnnamed)
	}
}

// WithXGet implements [main.MyInterface.XGet].
func WithXGet[T any, X II](implXGet func(qdCtx *QDMyInterfaceContext, ss *SI) *SI) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implXGet = append(d.implXGet, implXGet)
	}
}

// WithXGet2 implements [main.MyInterface.XGet2].
func WithXGet2[T any, X II](implXGet2 func(qdCtx *QDMyInterfaceContext, ss *XI) *XI) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implXGet2 = append(d.implXGet2, implXGet2)
	}
}

// Withinternal implements [main.MyInterface.internal].
func Withinternal[T any, X II](implinternal func(qdCtx *QDMyInterfaceContext) bool) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implinternal = append(d.implinternal, implinternal)
	}
}
