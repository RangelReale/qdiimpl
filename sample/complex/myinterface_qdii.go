// Code generated by "qdiimpl"; DO NOT EDIT.
package main

import (
	"context"
	"fmt"
	"runtime"
	"sync"
)

type QDMyInterfaceContext struct {
	ExecCount  int
	CallerFunc string
	CallerFile string
	CallerLine int
	Data       any
}

type qdMyInterface[T any, X II] struct {
	DataQDII any

	lock            sync.Mutex
	execCount       map[string]int
	fallback        MyInterface[T, X]
	implCloseNotify func(qdCtx *QDMyInterfaceContext) <-chan bool
	implData        func(qdCtx *QDMyInterfaceContext)
	implGet         func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string) (T, error)
	implOther       func(qdCtx *QDMyInterfaceContext, si SecondInterface) int
	implOther2      func(qdCtx *QDMyInterfaceContext, ti ThirdInterface[T]) int
	implSet         func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string, value T) error
	implUnnamed     func(qdCtx *QDMyInterfaceContext, p0 bool, p1 string)
	implXGet        func(qdCtx *QDMyInterfaceContext, ss *SI) *SI
	implXGet2       func(qdCtx *QDMyInterfaceContext, ss *XI) *XI
	implinternal    func(qdCtx *QDMyInterfaceContext) bool
}

type QDMyInterfaceOption[T any, X II] func(*qdMyInterface[T, X])

func NewQDMyInterface[T any, X II](options ...QDMyInterfaceOption[T, X]) MyInterface[T, X] {
	ret := &qdMyInterface[T, X]{execCount: map[string]int{}}
	for _, opt := range options {
		opt(ret)
	}
	return ret
}

// CloseNotify implements [main.MyInterface.CloseNotify].
func (d *qdMyInterface[T, X]) CloseNotify() <-chan bool {
	if d.implCloseNotify == nil && d.fallback != nil {
		return d.fallback.CloseNotify()
	}
	return d.implCloseNotify(d.createContext("CloseNotify", d.implCloseNotify == nil))
}

// Data implements [main.MyInterface.Data].
func (d *qdMyInterface[T, X]) Data() {
	if d.implData == nil && d.fallback != nil {
		d.fallback.Data()
		return
	}
	d.implData(d.createContext("Data", d.implData == nil))
}

// Get implements [main.MyInterface.Get].
func (d *qdMyInterface[T, X]) Get(ctx context.Context, name string) (T, error) {
	if d.implGet == nil && d.fallback != nil {
		return d.fallback.Get(ctx, name)
	}
	return d.implGet(d.createContext("Get", d.implGet == nil), ctx, name)
}

// Other implements [main.MyInterface.Other].
func (d *qdMyInterface[T, X]) Other(si SecondInterface) int {
	if d.implOther == nil && d.fallback != nil {
		return d.fallback.Other(si)
	}
	return d.implOther(d.createContext("Other", d.implOther == nil), si)
}

// Other2 implements [main.MyInterface.Other2].
func (d *qdMyInterface[T, X]) Other2(ti ThirdInterface[T]) int {
	if d.implOther2 == nil && d.fallback != nil {
		return d.fallback.Other2(ti)
	}
	return d.implOther2(d.createContext("Other2", d.implOther2 == nil), ti)
}

// Set implements [main.MyInterface.Set].
func (d *qdMyInterface[T, X]) Set(ctx context.Context, name string, value T) error {
	if d.implSet == nil && d.fallback != nil {
		return d.fallback.Set(ctx, name, value)
	}
	return d.implSet(d.createContext("Set", d.implSet == nil), ctx, name, value)
}

// Unnamed implements [main.MyInterface.Unnamed].
func (d *qdMyInterface[T, X]) Unnamed(p0 bool, p1 string) {
	if d.implUnnamed == nil && d.fallback != nil {
		d.fallback.Unnamed(p0, p1)
		return
	}
	d.implUnnamed(d.createContext("Unnamed", d.implUnnamed == nil), p0, p1)
}

// XGet implements [main.MyInterface.XGet].
func (d *qdMyInterface[T, X]) XGet(ss *SI) *SI {
	if d.implXGet == nil && d.fallback != nil {
		return d.fallback.XGet(ss)
	}
	return d.implXGet(d.createContext("XGet", d.implXGet == nil), ss)
}

// XGet2 implements [main.MyInterface.XGet2].
func (d *qdMyInterface[T, X]) XGet2(ss *XI) *XI {
	if d.implXGet2 == nil && d.fallback != nil {
		return d.fallback.XGet2(ss)
	}
	return d.implXGet2(d.createContext("XGet2", d.implXGet2 == nil), ss)
}

// internal implements [main.MyInterface.internal].
func (d *qdMyInterface[T, X]) internal() bool {
	if d.implinternal == nil && d.fallback != nil {
		return d.fallback.internal()
	}
	return d.implinternal(d.createContext("internal", d.implinternal == nil))
}

func (d *qdMyInterface[T, X]) getCallerFuncName(skip int) (funcName string, file string, line int) {
	counter, file, line, success := runtime.Caller(skip)
	if !success {
		panic("runtime.Caller failed")
	}
	return runtime.FuncForPC(counter).Name(), file, line
}

func (d *qdMyInterface[T, X]) checkCallMethod(methodName string, implIsNil bool) (count int) {
	if implIsNil {
		panic(fmt.Errorf("[qdMyInterface] method '%s' not implemented", methodName))
	}
	d.lock.Lock()
	defer d.lock.Unlock()
	d.execCount[methodName]++
	return d.execCount[methodName]
}

func (d *qdMyInterface[T, X]) createContext(methodName string, implIsNil bool) *QDMyInterfaceContext {
	callerFunc, callerFile, callerLine := d.getCallerFuncName(3)
	return &QDMyInterfaceContext{ExecCount: d.checkCallMethod(methodName, implIsNil), CallerFunc: callerFunc, CallerFile: callerFile, CallerLine: callerLine, Data: d.DataQDII}
}

// Options

func WithDataQDII[T any, X II](data any) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.DataQDII = data
	}
}
func WithFallback[T any, X II](fallback MyInterface[T, X]) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.fallback = fallback
	}
}

// WithCloseNotify implements [main.MyInterface.CloseNotify].
func WithCloseNotify[T any, X II](implCloseNotify func(qdCtx *QDMyInterfaceContext) <-chan bool) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implCloseNotify = implCloseNotify
	}
}

// WithData implements [main.MyInterface.Data].
func WithData[T any, X II](implData func(qdCtx *QDMyInterfaceContext)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implData = implData
	}
}

// WithGet implements [main.MyInterface.Get].
func WithGet[T any, X II](implGet func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string) (T, error)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implGet = implGet
	}
}

// WithOther implements [main.MyInterface.Other].
func WithOther[T any, X II](implOther func(qdCtx *QDMyInterfaceContext, si SecondInterface) int) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implOther = implOther
	}
}

// WithOther2 implements [main.MyInterface.Other2].
func WithOther2[T any, X II](implOther2 func(qdCtx *QDMyInterfaceContext, ti ThirdInterface[T]) int) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implOther2 = implOther2
	}
}

// WithSet implements [main.MyInterface.Set].
func WithSet[T any, X II](implSet func(qdCtx *QDMyInterfaceContext, ctx context.Context, name string, value T) error) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implSet = implSet
	}
}

// WithUnnamed implements [main.MyInterface.Unnamed].
func WithUnnamed[T any, X II](implUnnamed func(qdCtx *QDMyInterfaceContext, p0 bool, p1 string)) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implUnnamed = implUnnamed
	}
}

// WithXGet implements [main.MyInterface.XGet].
func WithXGet[T any, X II](implXGet func(qdCtx *QDMyInterfaceContext, ss *SI) *SI) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implXGet = implXGet
	}
}

// WithXGet2 implements [main.MyInterface.XGet2].
func WithXGet2[T any, X II](implXGet2 func(qdCtx *QDMyInterfaceContext, ss *XI) *XI) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implXGet2 = implXGet2
	}
}

// Withinternal implements [main.MyInterface.internal].
func Withinternal[T any, X II](implinternal func(qdCtx *QDMyInterfaceContext) bool) QDMyInterfaceOption[T, X] {
	return func(d *qdMyInterface[T, X]) {
		d.implinternal = implinternal
	}
}
