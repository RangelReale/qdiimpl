// Code generated by "qdiimpl"; DO NOT EDIT.
package main

import (
	"fmt"
	"io"
	"runtime"
	"sync"
)

type QDReaderContext struct {
	ExecCount  int
	CallerFunc string
	CallerFile string
	CallerLine int
}

type qdReader struct {
	lock      sync.Mutex
	execCount map[string]int
	fallback  io.Reader
	implRead  func(qdCtx *QDReaderContext, p []byte) (n int, err error)
}

var _ io.Reader = (*qdReader)(nil)

type QDReaderOption func(*qdReader)

func NewQDReader(options ...QDReaderOption) io.Reader {
	ret := &qdReader{execCount: map[string]int{}}
	for _, opt := range options {
		opt(ret)
	}
	return ret
}

// Read implements [io.Reader.Read].
func (d *qdReader) Read(p []byte) (n int, err error) {
	if d.implRead == nil && d.fallback != nil {
		return d.fallback.Read(p)
	}
	return d.implRead(d.createContext("Read", d.implRead == nil), p)
}

func (d *qdReader) getCallerFuncName(skip int) (funcName string, file string, line int) {
	counter, file, line, success := runtime.Caller(skip)
	if !success {
		panic("runtime.Caller failed")
	}
	return runtime.FuncForPC(counter).Name(), file, line
}

func (d *qdReader) checkCallMethod(methodName string, implIsNil bool) (count int) {
	if implIsNil {
		panic(fmt.Errorf("[qdReader] method '%s' not implemented", methodName))
	}
	d.lock.Lock()
	defer d.lock.Unlock()
	d.execCount[methodName]++
	return d.execCount[methodName]
}

func (d *qdReader) createContext(methodName string, implIsNil bool) *QDReaderContext {
	callerFunc, callerFile, callerLine := d.getCallerFuncName(3)
	return &QDReaderContext{ExecCount: d.checkCallMethod(methodName, implIsNil), CallerFunc: callerFunc, CallerFile: callerFile, CallerLine: callerLine}
}

// Options

func WithQDReaderFallback(fallback io.Reader) QDReaderOption {
	return func(d *qdReader) {
		d.fallback = fallback
	}
}

// WithQDReaderRead implements [io.Reader.Read].
func WithQDReaderRead(implRead func(qdCtx *QDReaderContext, p []byte) (n int, err error)) QDReaderOption {
	return func(d *qdReader) {
		d.implRead = implRead
	}
}
