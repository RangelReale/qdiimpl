# qdiimpl - Quick'n'Dirty Interface Implementation (for Golang)

# Samples

### io.Reader

```shell
$ go run github.com/RangelReale/qdiimpl/cmd/qdiimpl -type=Reader -package=io -force-package=main
```

File: `reader_qdii.go`

```go
// Code generated by "qdiimpl"; DO NOT EDIT.
package main

import (
    "fmt"
    "io"
    "runtime"
)

type DebugReaderContext struct {
    ExecCount  int
    CallerFunc string
    CallerFile string
    CallerLine int
    Data       any
}

type debugReader struct {
    execCount map[string]int
    data      any

    implRead func(debugCtx *DebugReaderContext, p []byte) (n int, err error)
}

var _ io.Reader = (*debugReader)(nil)

type DebugReaderOption func(*debugReader)

func NewDebugReader(options ...DebugReaderOption) io.Reader {
    ret := &debugReader{execCount: map[string]int{}}
    for _, opt := range options {
        opt(ret)
    }
    return ret
}

func (d *debugReader) Read(p []byte) (n int, err error) {
    return d.implRead(d.createContext("Read", d.implRead == nil), p)
}

func (d *debugReader) getCallerFuncName(skip int) (funcName string, file string, line int) {
    counter, file, line, success := runtime.Caller(skip)
    if !success {
        panic("runtime.Caller failed")
    }
    return runtime.FuncForPC(counter).Name(), file, line
}

func (d *debugReader) checkCallMethod(methodName string, implIsNil bool) (count int) {
    if implIsNil {
        panic(fmt.Errorf("[debugReader] method '%s' not implemented", methodName))
    }
    d.execCount[methodName]++
    return d.execCount[methodName]
}

func (d *debugReader) createContext(methodName string, implIsNil bool) *DebugReaderContext {
    callerFunc, callerFile, callerLine := d.getCallerFuncName(3)
    return &DebugReaderContext{ExecCount: d.checkCallMethod(methodName, implIsNil), CallerFunc: callerFunc, CallerFile: callerFile, CallerLine: callerLine, Data: d.data}
}

// Options

func WithDebugReaderData(data any) DebugReaderOption {
    return func(d *debugReader) {
        d.data = data
    }
}

func WithDebugReaderRead(implRead func(debugCtx *DebugReaderContext, p []byte) (n int, err error)) DebugReaderOption {
    return func(d *debugReader) {
        d.implRead = implRead
    }
}
```

Usage:

```go
func main() {
    reader := NewDebugReader(
        WithDebugReaderRead(func(debugCtx *DebugReaderContext, p []byte) (n int, err error) {
            n = copy(p, []byte("test"))
            return n, nil
        }),
    )

    readInterface(reader)
}

func readInterface(r io.Reader) {
    b := make([]byte, 10)

    n, err := r.Read(b)
    if err != nil {
        panic(err)
    }

    fmt.Printf("%d: %v", n, b)
}
```


# Author

Rangel Reale (rangelreale@gmail.com)
